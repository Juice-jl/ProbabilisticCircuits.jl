var documenterSearchIndex = {"docs":
[{"location":"api/internals/probabilistic_circuits/#api-internal-probabilistic","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"","category":"section"},{"location":"api/internals/probabilistic_circuits/","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"Modules = [ProbabilisticCircuits]","category":"page"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.BitCircuitPair","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.BitCircuitPair","text":"A bit circuit pair is a low-level representation of pairs of nodes traversed for a pair of probabilistic circuit logical circuit structure. For example, this is used for taking expectation of a Logistic/Regression circuit w.r.t. a probabilistic circuit.\n\nThe wiring of the circuit is captured by two matrices: nodes and elements.\n\nNodes are either leafs (input) or pair of Sum nodes\nElements are Pair of Product nodes \nIn addition, there is a vector of layers, where each layer is a list of node ids. Layer 1 is the leaf/input layer. Layer end is the circuit root.\nAnd there is a vector of parents, pointing to element id parents of decision nodes.\n\nNodes are represented as a 6xN matrix where\n\nnodes[1,:] is the first child pair id \nnodes[2,:] is the last child pair id \nnodes[3,:] is the first parent index \nnodes[4,:] is the last parent index \nnodes[5,:] is the id of corresponding node from the PC (first circuit)\nnodes[6,:] is the id of corresponding node from the LC (first circuit)\n\nElements are represented by a 3xE matrix, where \n\nelements[1,:] is the Product pair node id,\nelements[2,:] is the (left,left) child node id \nelements[3,:] is the (right right) child node id \n\nElements belonging to node pair i are elements[:, nodes[1,i]:nodes[2,i]] \n\nParents are represented as a one dimentional array       Parents belonging to node pair i are parents[nodes[3,i]:nodes[4,i]]\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.CLT","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.CLT","text":"Chow-Liu Tree\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ExpFlowCircuit-Union{Tuple{El}, Tuple{ProbCircuit,LogisticCircuit,Int64,Type{El}}} where El","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ExpFlowCircuit","text":"Construct a upward expectation flow circuit from a given pair of PC and LC circuits Note that its assuming the two circuits share the same vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ExpFlowNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ExpFlowNode","text":"A expectation circuit node that has pair of origins of type PC and type LC\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.LogisticCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.LogisticCircuit","text":"Root of the logistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.LogisticInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.LogisticInnerNode","text":"A logistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.LogisticLeafNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.LogisticLeafNode","text":"A logistic leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.LogisticLiteralNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.LogisticLiteralNode","text":"A logistic literal node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Logistic⋀Node","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Logistic⋀Node","text":"A logistic conjunction node (And node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Logistic⋁Node","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Logistic⋁Node","text":"A logistic disjunction node (Or node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodePairId","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodePairId","text":"Integer identifier for a circuit pair node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodePairIds","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodePairIds","text":"The BitCircuitPair ids associated with a node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ParamBitCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ParamBitCircuit","text":"A BitCircuit with parameters attached to the elements\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainMulNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainMulNode","text":"A probabilistic conjunction node (multiplication node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbCircuit","text":"Root of the plain probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbInnerNode","text":"A probabilistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbLeafNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbLeafNode","text":"A probabilistic leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbLiteralNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbLiteralNode","text":"A probabilistic literal node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainSumNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainSumNode","text":"A probabilistic disjunction node (summation node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ProbCircuit","text":"Root of the probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ProbCircuit-Tuple","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ProbCircuit","text":"Evaluate a probabilistic circuit as a function\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedMulNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedMulNode","text":"A shared probabilistic multiplcation node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedProbCircuit","text":"Root of the shared probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedProbInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedProbInnerNode","text":"A shared probabilistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedProbLeafNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedProbLeafNode","text":"A shared probabilistic leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedProbLiteralNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedProbLiteralNode","text":"A shared probabilistic literal node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.SharedSumNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.SharedSumNode","text":"A shared probabilistic summation node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructMulNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructMulNode","text":"A plain structured probabilistic conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructProbCircuit","text":"Root of the plain structure probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructProbInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructProbInnerNode","text":"A plain structured probabilistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructProbLeafNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructProbLeafNode","text":"A plain structured probabilistic leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructProbLiteralNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructProbLiteralNode","text":"A plain structured probabilistic literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.StructSumNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.StructSumNode","text":"A plain structured probabilistic disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#LogicCircuits.Utils.print_tree-Tuple{MetaGraphs.MetaDiGraph}","page":"Probabilistic Circuits","title":"LogicCircuits.Utils.print_tree","text":"Print edges and vertices of a ChowLiu tree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#LogicCircuits.vtree-Tuple{StructProbCircuit}","page":"Probabilistic Circuits","title":"LogicCircuits.vtree","text":"Get the vtree corresponding to the argument, or nothing if the node has no vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.EVI","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.EVI","text":"EVI(pc, data)\n\nComputes the log likelihood data given full evidence. Outputs logp(x) for each datapoint.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Expectation-Tuple{ProbCircuit,LogisticCircuit,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Expectation","text":"Expectation(pc::ProbCircuit, lc::LogisticCircuit, data)\n\nCompute Expected Prediction of a Logistic/Regression Circuit w.r.t to a ProbabilistcCircuit\n\nMissing values should be denoted by missing See: On Tractable Computation of Expected Predictions arxiv.org/abs/1910.02182\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ExpectationBit-Tuple{ProbCircuit,LogisticCircuit,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ExpectationBit","text":"ExpectationBit(pc::ProbCircuit, lc::LogisticCircuit, data)\nExpectationBit(pbc::ParamBitCircuitPair, pc::ProbCircuit, lc::LogisticCircuit, data)\n\nCompute Expected Prediction of a Logistic/Regression Circuit w.r.t to a ProbabilistcCircuit. Uses the BitCircuitPair implementation, which enables parrallism on both CPU/GPU. If the data is on gpu the gpu version will get called (repectively for cpu.)\n\nMissing values should be denoted by missing See: On Tractable Computation of Expected Predictions arxiv.org/abs/1910.02182\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ExpectationUpward-Tuple{ProbCircuit,LogisticCircuit,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ExpectationUpward","text":"Expected Prediction of LC w.r.t PC. This implementation uses the computation graph approach.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.MAP","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.MAP","text":"Maximum a-posteriori queries\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.MAR","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.MAR","text":"MAR(pc, data)\n\nComputes Marginal log likelhood of data. See docs for marginal.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Moment-Tuple{ProbCircuit,LogisticCircuit,Any,Int64}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Moment","text":"Moment(pc::ProbCircuit, lc::LogisticCircuit, data, moment::Int)\n\nCompute higher moments of Expected Prediction for the pair of Logistic/Regression Circuit, ProbabilistcCircuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.apply_entropy_reg_cpu-Tuple{LogicCircuits.BitCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.apply_entropy_reg_cpu","text":"Add entropy regularization to a deterministic (see LogicCircuits.isdeterministic) probabilistic circuit. alpha is a hyperparameter that balances the weights between the likelihood and the  entropy: \u0007rgmax{\theta} L(\theta) = llmean(\theta) + alpha * entropy(\theta).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.compile_canonical_literals-Tuple{UInt32,LogicCircuits.PlainVtreeLeafNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.compile_canonical_literals","text":"Construct literal nodes given variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.compile_decision_node-Tuple{Array{var\"#s158\",1} where var\"#s158\"<:LogicCircuits.PlainStructLogicCircuit,Array{var\"#s157\",1} where var\"#s157\"<:LogicCircuits.PlainStructLogicCircuit,LogicCircuits.PlainVtreeInnerNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.compile_decision_node","text":"Construct decision nodes given primes and subs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.compile_decision_nodes-Tuple{Array{var\"#s155\",1} where var\"#s155\"<:LogicCircuits.PlainStructLogicCircuit,Array{var\"#s154\",1} where var\"#s154\"<:LogicCircuits.PlainStructLogicCircuit,LogicCircuits.PlainVtreeInnerNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.compile_decision_nodes","text":"Construct decision nodes conditiond on different distribution\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.compile_sdd_from_clt-Tuple{MetaGraphs.MetaDiGraph,LogicCircuits.PlainVtree}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.compile_sdd_from_clt","text":"Compile a psdd circuit from clt and vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.compile_true_nodes-Tuple{UInt32,LogicCircuits.PlainVtreeLeafNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.compile_true_nodes","text":"Construct true nodes given variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eFlow-Tuple{Any,Any,Array{Tuple{LogicCircuits.Utils.Node,LogicCircuits.Utils.Node},1},Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eFlow","text":"Pick the edge with maximum flow\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eRand-Tuple{Array{Tuple{LogicCircuits.Utils.Node,LogicCircuits.Utils.Node},1}}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eRand","text":"Pick the edge randomly\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.estimate_parameters-Tuple{ProbCircuit,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.estimate_parameters","text":"Maximum likilihood estimation of parameters given data\n\nuse_gpu: If set to true, use gpu learning no matter which device data is in.\n\nbagging support: If pc is a SharedProbCircuit and data is an array of DataFrames   with the same number of \"components\", learn each circuit with its corresponding    dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.estimate_parameters_em-Tuple{ProbCircuit,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.estimate_parameters_em","text":"Expectation maximization parameter learning given missing data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.exp_f-Tuple{Union{PlainProbLiteralNode, StructProbLiteralNode},Logistic⋁Node,Any,Union{ProbabilisticCircuits.ExpectationCache, ProbabilisticCircuits.MomentCache}}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.exp_f","text":"Has to be a Logistic⋁Node with only one child, which is a leaf node \n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.exp_fg-Tuple{Union{PlainProbLiteralNode, StructProbLiteralNode},Logistic⋁Node,Any,ProbabilisticCircuits.ExpectationCache}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.exp_fg","text":"Has to be a Logistic⋁Node with only one child, which is a leaf node \n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.get_cpt-Tuple{Any,Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.get_cpt","text":"Calculate CPT of child conditioned on parent from dis_cache\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.init_expectations-Tuple{ParamBitCircuitPair,Any,Any,Any,Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.init_expectations","text":"init_expectations(circuit::ParamBitCircuitPair, data, reuse_f, reuse_g, nodes_num, classes_num; Float = Float32)\n\nInitialized the input layer for `fvalues` and `gvalues`. \nTo reduce memory allocation can pass `reuse_f` and `reuse_g` to get reused (very useful during batching).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.init_marginal-Tuple{Any,Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.init_marginal","text":"Initialize values from the data (data frames)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ismul-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ismul","text":"Is the node a multiplication?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.issum-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.issum","text":"Is the node a summation?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.kl_divergence","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.kl_divergence","text":"Calculate KL divergence calculation for pcs that are not necessarily identical\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_chow_liu_tree-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_chow_liu_tree","text":"learn a Chow-Liu tree from training set train_x, with Laplace smoothing factor α, specifying the tree root by clt_root return a CLT\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_chow_liu_tree_circuit-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_chow_liu_tree_circuit","text":"Learning from data a structured-decomposable circuit with several structure learning algorithms\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_circuit-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_circuit","text":"Learn structure of a single structured decomposable circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_circuit_miss-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_circuit_miss","text":"Learn structure of a single structured decomposable circuit from missing data. \n\nMissing feature are denoted by missing.  Median Imputation is used by default for initial structure (set impute_method for other options).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_circuit_mixture-Tuple{Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_circuit_mixture","text":"Given a circuit, learns a mixture of structure decomposable circuits based on that circuit\n\nlearn_circuit_mixture(pc, data; num_mix=5, pseudocount=1.0, maxiter=20)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_strudel-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_strudel","text":"learn_strudel(train_x; num_mix = 5, init_maxiter = 10, em_maxiter=20)\n\nLearn a mixture of circuits See \"Strudel: Learning Structured-Decomposable Probabilistic Circuits. arxiv.org/abs/2007.09331\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.learn_vtree_from_clt-Tuple{MetaGraphs.MetaDiGraph}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.learn_vtree_from_clt","text":"Learn a vtree from clt, with strategy (close to) linear or balanced\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.log_likelihood-Tuple{Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.log_likelihood","text":"log_likelihood(pc, data)\n\nCompute the likelihood of the PC given the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.log_likelihood_avg-Tuple{Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.log_likelihood_avg","text":"log_likelihood_avg(pc, data)\n\nCompute the likelihood of the PC given the data, averaged over all instances in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.log_likelihood_per_instance","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.log_likelihood_per_instance","text":"Compute the likelihood of the PC given each individual instance in the data\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.map_child-NTuple{6,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.map_child","text":"Find the MAP child value and node id of a given decision node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal-Tuple{ProbCircuit,Vararg{Union{Missing, Real},N} where N}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal","text":"marginal(root::ProbCircuit, data::Union{Real,Missing}...)\nmarginal(root::ProbCircuit, data::Union{Vector{Union{Bool,Missing}},CuVector{UInt8}})\nmarginal(circuit::ProbCircuit, data::DataFrame)\nmarginal(circuit::ParamBitCircuit, data::DataFrame)::AbstractVector\nmarginal(circuit::SharedProbCircuit, data::DataFrame, weights::Union{AbstractArray, Nothing}; component_idx)\n\nEvaluate marginals of the circuit bottom-up for given input(s).\n\nMissing values should be denoted by missing in the data.\n\nOutputs logp(x^o) for each data point. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_all-Tuple{ProbCircuit,DataFrames.DataFrame}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_all","text":"Evaluate the probabilistic circuit bottom-up for a given input and return the marginal probability value of all nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_flows","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_flows","text":"Compute the marginal and flow of each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_flows_down","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_flows_down","text":"When marginals of nodes have already been computed, do a downward pass computing the marginal flows at each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_flows_down_layers-Tuple{ParamBitCircuit,Array{T,2} where T,Array{T,2} where T,Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_flows_down_layers","text":"Evaluate marginals of the layers of a parameter bit circuit on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_flows_down_layers-Tuple{ParamBitCircuit,CUDA.CuArray{T,2} where T,CUDA.CuArray{T,2} where T,Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_flows_down_layers","text":"Pass marginal flows down the layers of a bit circuit on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_flows_down_layers_cuda-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Nothing}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_flows_down_layers_cuda","text":"CUDA kernel for passing marginal flows down circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_layers-Tuple{ParamBitCircuit,Array{T,2} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_layers","text":"Compute marginals on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_layers-Tuple{ParamBitCircuit,CUDA.CuArray{T,2} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_layers","text":"Compute marginals on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_layers_cuda-NTuple{5,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_layers_cuda","text":"CUDA kernel for circuit evaluation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_log_likelihood-Tuple{Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_log_likelihood","text":"marginal_log_likelihood(pc, data)\n\nCompute the marginal likelihood of the PC given the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.marginal_log_likelihood_avg-Tuple{Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.marginal_log_likelihood_avg","text":"Compute the marginal likelihood of the PC given the data, averaged over all instances in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.max_a_posteriori-Tuple{ProbCircuit,Vararg{Union{Missing, Bool},N} where N}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.max_a_posteriori","text":"max_a_posteriori(root::ProbCircuit, data::Union{Bool,Missing}...)\nmax_a_posteriori(root::ProbCircuit, data::Union{Vector{<:Union{Bool,Missing}},CuVector{UInt8}})\nmax_a_posteriori(circuit::ProbCircuit, data::DataFrame)\nmax_a_posteriori(pbc::ParamBitCircuit, data; Float=Float32)\n\nEvaluate maximum a-posteriori state of the circuit for given input(s).\n\nOutputs the states, and the corresponding probabilities (in log domain).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.metis_top_down-Tuple{DataFrames.DataFrame}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.metis_top_down","text":"Metis top down method\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mode","text":"Mode of the distribution\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.moment_fg-Tuple{Union{PlainSumNode, StructSumNode},Logistic⋁Node,Any,Int64,ProbabilisticCircuits.MomentCache}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.moment_fg","text":"Calculating  E[g^k * f]\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mul_nodes-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mul_nodes","text":"Get the list of multiplication nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.multiply","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.multiply","text":"Multiply nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_components-Tuple{SharedSumNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_components","text":"How many components are mixed together in this shared circuit?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters","text":"Count the number of parameters in the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters_node-Tuple{PlainSumNode}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters_node","text":"Count the number of parameters in the node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.params-Tuple{Logistic⋁Node}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.params","text":"Get the parameters associated with a or node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.params-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.params","text":"Get the parameters associated with a sum node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.parent_vector-Tuple{MetaGraphs.MetaDiGraph}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.parent_vector","text":"Get parent vector of a tree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.pr_constraint","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.pr_constraint","text":"Calculate the probability of the logic formula given by LC for the PC\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples)\nsample(pc::ProbCircuit, num_samples, evidences)\n\nSample states from the probabilistic circuit distribution. Also can do conditional sampling if evidence is given (any subset of features).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sum_nodes-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sum_nodes","text":"Get the list of summation nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.summate","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.summate","text":"Sum nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.to_sampled_dataframes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.to_sampled_dataframes","text":"Convert an array of samples into a vector of dataframes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.uniform_parameters-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.uniform_parameters","text":"Uniform distribution\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.vMI-Tuple{Any,Any,Any,Array{UInt32,1},Any,Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.vMI","text":"Pick the variable with maximum sum of mutual information\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.vRand-Tuple{Array{UInt32,1}}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.vRand","text":"Pick the variable randomly\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.wmc_chavira","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.wmc_chavira","text":"wmc_chavira(root::LogicCircuit; varprob::Function)::Float\n\nCompute weighted model count in the context of a chavira encoding (default negative literals to 1) Probability of each variable is given by varprob Function which defauls to 1/2 for every variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/learning/#man-learning","page":"Learning","title":"Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"In this section we provide few learning scenarios for circuits. In general, learning tasks for PCs can be separted into two categories: parameter learning and structure learning.","category":"page"},{"location":"manual/learning/#Learn-a-Circuit","page":"Learning","title":"Learn a Circuit","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"You can use learn_circuit to learn a probabilistic circuit from the data (both parameter and structure learning).","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"using LogicCircuits\nusing ProbabilisticCircuits\ntrain_x, valid_x, test_x = twenty_datasets(\"nltcs\")\n\npc = learn_circuit(train_x; maxiter=100);\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters. \" *  \n\"Train log-likelihood is $(log_likelihood_avg(pc, train_x))\"","category":"page"},{"location":"manual/learning/#Learning-a-circuit-from-missing-data","page":"Learning","title":"Learning a circuit from missing data","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"You can use learn_circuit_miss to learn a probabilistic circuit from missing data, i.e. some feature could be missing for each data point.","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"train_x_miss = make_missing_mcar(train_x; keep_prob=0.9)\npc = learn_circuit_miss(train_x_miss; maxiter=100);\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters. \" *  \n\"Train marginal-log-likelihood is $(marginal_log_likelihood_avg(pc, train_x))\"","category":"page"},{"location":"manual/learning/#Learn-a-mixture-of-circuits","page":"Learning","title":"Learn a mixture of circuits","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"We also support learning mixture of circuits using the Strudel algorithm (learn_strudel).","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"using LogicCircuits\nusing ProbabilisticCircuits\nusing Statistics\n\ntrain_x, valid_x, test_x = twenty_datasets(\"nltcs\")\n\nspc, component_weights, lls = learn_strudel(train_x; num_mix = 10, init_maxiter = 20, em_maxiter = 100);\n\n\"SPC: $(num_nodes(spc)) nodes, $(num_parameters(spc)) parameters. \" *\n\"Train log-likelihood is $(mean(lls))\"","category":"page"},{"location":"manual/learning/#Misc-Options","page":"Learning","title":"Misc Options","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"In this sections, we provide options to have more control in learning circuits. For example, what if we only want to do parameter learning.","category":"page"},{"location":"manual/learning/#Parameter-Learning","page":"Learning","title":"Parameter Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Given a fixed structure for the PC, the goal of parameter learning is to estimate the parameters so that likelihood is maximized.","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"First, initliaze PC structure with a balanced vtree represneting a fully factorized distribution:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"v = Vtree(num_features(train_x), :balanced)\npc = fully_factorized_circuit(StructProbCircuit, v);\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters.\" *  \n\"Train log-likelihood is $(log_likelihood_avg(pc, train_x))\"  ","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"No parmater learning is done yet, now let's, do maximum likelihood estimatation (MLE) using estimate_parameters:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"estimate_parameters(pc, train_x; pseudocount=1.0);\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters.\" *\n\"Train log-likelihood is $(log_likelihood_avg(pc, train_x))\"  ","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"As we see the likelihood improved, however we are still using a fully factorized distribution. There is room for improvement. For example, we can choose initial structure based on Chow-Liu Trees.","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"pc, vtree = learn_chow_liu_tree_circuit(train_x)\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters.\" *\n\"Train log-likelihood is $(log_likelihood_avg(pc, train_x))\"  ","category":"page"},{"location":"manual/learning/#Structure-Learning","page":"Learning","title":"Structure Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"There are several different approaches in structure learning. Currently we support the following approach:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Choose an initial structure and learn parameters\nPerform Greedy search for a bigger and better structure by doing operations such as split and clone.\nRepeat step 2 until satisfied or time limit reached","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"We start with the Chow-Liu structure we learned in last section, and run few structure learning iterations (20):","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"pc, vtree = learn_chow_liu_tree_circuit(train_x)\nloss(circuit) = ProbabilisticCircuits.heuristic_loss(circuit, train_x)\npc = struct_learn(pc;  \n    primitives=[split_step],  \n    kwargs=Dict(split_step=>(loss=loss,)),\n    maxiter=20)\nestimate_parameters(pc, train_x; pseudocount=1.0)\n\n\"PC: $(num_nodes(pc)) nodes, $(num_parameters(pc)) parameters. \" *\n\"Training set log-likelihood is $(log_likelihood_avg(pc, train_x))\"  ","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.5 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-ProbabilisticCircuits","page":"Installation","title":"Installing ProbabilisticCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can also install the package with the latest commits on master branch. In that case, its also recommented to install the latest LogicCircuits:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add([PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"),PackageSpec(url=\"https://github.com/Juice-jl/ProbabilisticCircuits.jl.git\")])'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add ProbabilisticCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits#master\nadd ProbabilisticCircuits#master","category":"page"},{"location":"installation/#Optional-Dependencies","page":"Installation","title":"Optional Dependencies","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"We use Requires.jl to make some of our rarely used dependencies optional, so they do not automatically get installed.  Currently, BlossomV.jl is the only such dependency due to its rare ussage and issues with Windows. This means if you get an error related to BlossomV.jl, you can fix that by adding BlossomV to your project using Pkg.add.","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want the tests to run faster, you can use multiple cores. To do that set the following environment variable (default = 1 core):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"export JIVE_PROCS=8","category":"page"},{"location":"api/internals/loadsave/#api-internal-loadsave","page":"LoadSave","title":"LoadSave","text":"","category":"section"},{"location":"api/internals/loadsave/","page":"LoadSave","title":"LoadSave","text":"Modules = [ProbabilisticCircuits.LoadSave]","category":"page"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_dot-Tuple{String,ProbCircuit}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_dot","text":"Save prob circuits to .dot file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_circuit-Tuple{String,StructProbCircuit,LogicCircuits.PlainVtree}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_circuit","text":"Save a circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.compile_logistic-Tuple{AbstractArray{var\"#s136\",1} where var\"#s136\"<:LogicCircuits.LoadSave.CircuitFormatLine,Int64}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.compile_logistic","text":"Compile lines into a logistic circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.compile_prob-Tuple{AbstractArray{var\"#s136\",1} where var\"#s136\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.compile_prob","text":"Compile lines into a probabilistic circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.compile_struct_prob-Tuple{AbstractArray{var\"#s136\",1} where var\"#s136\"<:LogicCircuits.LoadSave.CircuitFormatLine,AbstractArray{var\"#s136\",1} where var\"#s136\"<:LogicCircuits.LoadSave.VtreeFormatLine}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.compile_struct_prob","text":"Compile circuit and vtree lines into a structured probabilistic circuit (one whose logic circuit origin is structured).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.decompile-Tuple{StructProbLiteralNode,Any,Any}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.decompile","text":"Decompile for psdd circuit, used during saving of circuits to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.load_logistic_circuit-Tuple{String,Int64}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.load_logistic_circuit","text":"Load a logistic circuit from file. Support circuit file formats:     * \".circuit\" for logistic files Supported vtree file formats:     * \".vtree\" for Vtree files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.load_prob_circuit-Tuple{String}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.load_prob_circuit","text":"Load a probabilistic circuit from file. Support circuit file formats:     * \".psdd\" for PSDD files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.load_struct_prob_circuit-Tuple{Union{IO, String},Union{IO, String}}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.load_struct_prob_circuit","text":"Load a structured probabilistic circuit from file. Support circuit file formats:     * \".psdd\" for PSDD files Supported vtree file formats:     * \".vtree\" for Vtree files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.parse_clt-Tuple{String}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.parse_clt","text":"Parse a clt from given file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.psdd_header-Tuple{}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.psdd_header","text":"Returns header for PSDD file format\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.save_as_logistic-Tuple{String,LogisticCircuit,Any}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.save_as_logistic","text":"Save a logistic circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#ProbabilisticCircuits.LoadSave.save_as_psdd-Tuple{Union{IO, String},ProbCircuit,LogicCircuits.PlainVtree}","page":"LoadSave","title":"ProbabilisticCircuits.LoadSave.save_as_psdd","text":"Save a circuit to PSDD file format\n\n\n\n\n\n","category":"method"},{"location":"manual/demo/#man-demo","page":"Quick Demo","title":"Quick Demo","text":"","category":"section"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"In this section, we provide quick code snippets to get started with ProbabilisticCircuits and provide basic understanding of them. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"Generally, we learn structure and paramters of circuit from data. Alternatively, we can also specify circuits in code. For example, the following snippet defines a circuit depending on 3 random variables. The literals function returns the input units of the circuit, in this case we get 6 different units (3 for positive literals, and 3 for negative literlas).  You can use * and + operators to build a circuits.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using LogicCircuits;\nusing ProbabilisticCircuits;\n\nX1, X2, X3 = literals(ProbCircuit, 3)\npc = 0.3 * (X1[1] *\n             (0.2 * X2[1] + 0.8 * X3[2])) +\n     0.7 * (X1[2] *\n             (0.4 * X2[2] + 0.6 * X3[1]));\n\nnothing # hide","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"We can also plot circuits using plot(pc) to see the computation graph (structure and paramters). The output of plot(pc) has a type of TikzPictures.TikzPicture. Generally, notebooks automatically renders it and you see the figure in the notebook. ","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using TikzPictures  # workaround\nTikzPictures.standaloneWorkaround(true)  # workaround\nplot(pc);","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"However, if you are not using a notebook or want to save to file you can use the following commands to save the plot in various formats.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using TikzPictures;\nz = plot(pc);\nsave(PDF(\"plot\"), z);\nsave(SVG(\"plot\"), z);\nsave(TEX(\"plot\"), z);\nsave(TIKZ(\"plot\"), z);","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"You can ask basic questions about PCs, such as (1) how many variables they depends on, (2) how many nodes, (3) how many edges, (4) or how many parameters they have.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_variables(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_nodes(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_edges(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_parameters(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"In the case that we have literals as input units, PCs can also be thought of as adding paramters to a LogicCircuit to define a distribution (See LogicCircuit.jl docs for more details). To get the corresponding logical formula, we can:","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"tree_formula_string(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"To enable tractable queries and opertations, PCs need to have certain structural properties. For example, we can check for smoothness and determinism as follows:","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"c1 = 0.4 * X1[1] + 0.6 * X1[2];\n\"Is $(tree_formula_string(c1)) smooth? $(issmooth(c1))\"\n","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"c2 = 0.4 * X1[1] + 0.6 * X2[2];\n\"Is $(tree_formula_string(c2)) smooth? $(issmooth(c2))\"","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"c1 = X1[1] * X2[1] + X1[1] * X2[2];\n\"Is $(tree_formula_string(c1)) deterministic? $(isdeterministic(c1))\" ","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"c2 = X1[1] * X2[1] + X1[1] * X2[1]\n\"Is $(tree_formula_string(c2)) deterministic? $(isdeterministic(c2))\"","category":"page"},{"location":"api/public/#api-public","page":"Public APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"This page lists documentation for the most commonly used public APIs of ProbabilisticCircuits.jl. Visit the internals section for a auto generated documentation for more public API and internal APIs.","category":"page"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Loading-Circuits","page":"Public APIs","title":"Loading Circuits","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"load_prob_circuit\nload_struct_prob_circuit\nload_logistic_circuit","category":"page"},{"location":"api/public/#ProbabilisticCircuits.LoadSave.load_prob_circuit","page":"Public APIs","title":"ProbabilisticCircuits.LoadSave.load_prob_circuit","text":"Load a probabilistic circuit from file. Support circuit file formats:     * \".psdd\" for PSDD files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.LoadSave.load_struct_prob_circuit","page":"Public APIs","title":"ProbabilisticCircuits.LoadSave.load_struct_prob_circuit","text":"Load a structured probabilistic circuit from file. Support circuit file formats:     * \".psdd\" for PSDD files Supported vtree file formats:     * \".vtree\" for Vtree files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.LoadSave.load_logistic_circuit","page":"Public APIs","title":"ProbabilisticCircuits.LoadSave.load_logistic_circuit","text":"Load a logistic circuit from file. Support circuit file formats:     * \".circuit\" for logistic files Supported vtree file formats:     * \".vtree\" for Vtree files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Saving-Interface","page":"Public APIs","title":"Saving Interface","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"save_circuit\nsave_as_psdd\nsave_as_logistic\nsave_as_dot","category":"page"},{"location":"api/public/#LogicCircuits.LoadSave.save_circuit","page":"Public APIs","title":"LogicCircuits.LoadSave.save_circuit","text":"Save a circuit to file\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.LoadSave.save_as_psdd","page":"Public APIs","title":"ProbabilisticCircuits.LoadSave.save_as_psdd","text":"Save a circuit to PSDD file format\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.LoadSave.save_as_logistic","page":"Public APIs","title":"ProbabilisticCircuits.LoadSave.save_as_logistic","text":"Save a logistic circuit to file\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_as_dot","page":"Public APIs","title":"LogicCircuits.LoadSave.save_as_dot","text":"Save prob circuits to .dot file\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Learning-Circuits","page":"Public APIs","title":"Learning Circuits","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"learn_circuit\nlearn_strudel\nestimate_parameters\nlearn_parameters\nlearn_chow_liu_tree_circuit","category":"page"},{"location":"api/public/#ProbabilisticCircuits.learn_circuit","page":"Public APIs","title":"ProbabilisticCircuits.learn_circuit","text":"Learn structure of a single structured decomposable circuit\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.learn_strudel","page":"Public APIs","title":"ProbabilisticCircuits.learn_strudel","text":"learn_strudel(train_x; num_mix = 5, init_maxiter = 10, em_maxiter=20)\n\nLearn a mixture of circuits See \"Strudel: Learning Structured-Decomposable Probabilistic Circuits. arxiv.org/abs/2007.09331\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.estimate_parameters","page":"Public APIs","title":"ProbabilisticCircuits.estimate_parameters","text":"Maximum likilihood estimation of parameters given data\n\nuse_gpu: If set to true, use gpu learning no matter which device data is in.\n\nbagging support: If pc is a SharedProbCircuit and data is an array of DataFrames   with the same number of \"components\", learn each circuit with its corresponding    dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.Logistic.learn_parameters","page":"Public APIs","title":"ProbabilisticCircuits.Logistic.learn_parameters","text":"LogisticCircuit Parameter learning through gradient descents Note: data need to be DataFrame and Labels need to be in one-hot form.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.learn_chow_liu_tree_circuit","page":"Public APIs","title":"ProbabilisticCircuits.learn_chow_liu_tree_circuit","text":"Learning from data a structured-decomposable circuit with several structure learning algorithms\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Queries","page":"Public APIs","title":"Circuit Queries","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"marginal\nmax_a_posteriori\nsample\nExpectation\nMoment","category":"page"},{"location":"api/public/#ProbabilisticCircuits.marginal","page":"Public APIs","title":"ProbabilisticCircuits.marginal","text":"marginal(root::ProbCircuit, data::Union{Real,Missing}...)\nmarginal(root::ProbCircuit, data::Union{Vector{Union{Bool,Missing}},CuVector{UInt8}})\nmarginal(circuit::ProbCircuit, data::DataFrame)\nmarginal(circuit::ParamBitCircuit, data::DataFrame)::AbstractVector\nmarginal(circuit::SharedProbCircuit, data::DataFrame, weights::Union{AbstractArray, Nothing}; component_idx)\n\nEvaluate marginals of the circuit bottom-up for given input(s).\n\nMissing values should be denoted by missing in the data.\n\nOutputs logp(x^o) for each data point. \n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.max_a_posteriori","page":"Public APIs","title":"ProbabilisticCircuits.max_a_posteriori","text":"max_a_posteriori(root::ProbCircuit, data::Union{Bool,Missing}...)\nmax_a_posteriori(root::ProbCircuit, data::Union{Vector{<:Union{Bool,Missing}},CuVector{UInt8}})\nmax_a_posteriori(circuit::ProbCircuit, data::DataFrame)\nmax_a_posteriori(pbc::ParamBitCircuit, data; Float=Float32)\n\nEvaluate maximum a-posteriori state of the circuit for given input(s).\n\nOutputs the states, and the corresponding probabilities (in log domain).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.sample","page":"Public APIs","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples)\nsample(pc::ProbCircuit, num_samples, evidences)\n\nSample states from the probabilistic circuit distribution. Also can do conditional sampling if evidence is given (any subset of features).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.Expectation","page":"Public APIs","title":"ProbabilisticCircuits.Expectation","text":"Expectation(pc::ProbCircuit, lc::LogisticCircuit, data)\n\nCompute Expected Prediction of a Logistic/Regression Circuit w.r.t to a ProbabilistcCircuit\n\nMissing values should be denoted by missing See: On Tractable Computation of Expected Predictions arxiv.org/abs/1910.02182\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.Moment","page":"Public APIs","title":"ProbabilisticCircuits.Moment","text":"Moment(pc::ProbCircuit, lc::LogisticCircuit, data, moment::Int)\n\nCompute higher moments of Expected Prediction for the pair of Logistic/Regression Circuit, ProbabilistcCircuit\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Compilation","page":"Public APIs","title":"Compilation","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"compile_sdd_from_clt","category":"page"},{"location":"api/public/#ProbabilisticCircuits.compile_sdd_from_clt","page":"Public APIs","title":"ProbabilisticCircuits.compile_sdd_from_clt","text":"Compile a psdd circuit from clt and vtree\n\n\n\n\n\n","category":"function"},{"location":"api/types/#api-types","page":"Type Trees","title":"Type Trees","text":"","category":"section"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"The following code snippet provides an easy way to print the type tree of probabilistic circuits.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"using InteractiveUtils;\nusing ProbabilisticCircuits;\nusing AbstractTrees;\nAbstractTrees.children(x::Type) = subtypes(x);","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"For example, we can see ProbabilisticCircuits.ProbCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(ProbCircuit)","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"Alternatively, here's ProbabilisticCircuits.LogisticCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(LogisticCircuit)","category":"page"},{"location":"api/internals/logistic/#api-internal-logistic","page":"Logistic Circuits","title":"Logistic Circuits","text":"","category":"section"},{"location":"api/internals/logistic/","page":"Logistic Circuits","title":"Logistic Circuits","text":"Modules = [ProbabilisticCircuits.Logistic]","category":"page"},{"location":"api/internals/logistic/#ProbabilisticCircuits.Logistic.accuracy-Tuple{LogisticCircuit,Int64,Any,Array{T,1} where T}","page":"Logistic Circuits","title":"ProbabilisticCircuits.Logistic.accuracy","text":"Prediction accuracy\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logistic/#ProbabilisticCircuits.Logistic.class_likelihood_per_instance-Tuple{LogisticCircuit,Int64,Any}","page":"Logistic Circuits","title":"ProbabilisticCircuits.Logistic.class_likelihood_per_instance","text":"Class Conditional Probability\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logistic/#ProbabilisticCircuits.Logistic.learn_parameters-Tuple{LogisticCircuit,Int64,Any,Any}","page":"Logistic Circuits","title":"ProbabilisticCircuits.Logistic.learn_parameters","text":"LogisticCircuit Parameter learning through gradient descents Note: data need to be DataFrame and Labels need to be in one-hot form.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logistic/#ProbabilisticCircuits.Logistic.predict_class-Tuple{LogisticCircuit,Int64,Any}","page":"Logistic Circuits","title":"ProbabilisticCircuits.Logistic.predict_class","text":"Class Predictions\n\n\n\n\n\n","category":"method"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this section, we go over most common probabilistic reasoning tasks, and provide code snippets to compute those queries. ","category":"page"},{"location":"manual/queries/#Setup","page":"Queries","title":"Setup","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we load some pretrained PC, and the corresponding data.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"# This is needed to hide output from downloading artifacts\nusing LogicCircuits # hide\nusing ProbabilisticCircuits; #hide\npc = zoo_psdd(\"plants.psdd\")\ndata, _, _ = twenty_datasets(\"plants\");","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nusing ProbabilisticCircuits; #hide\npc = zoo_psdd(\"plants.psdd\")\ndata, _, _ = twenty_datasets(\"plants\");\nprintln(\"circuit with $(num_nodes(pc)) nodes and $(num_parameters(pc)) parameters.\")\nprintln(\"dataset with $(num_features(data)) features and $(num_examples(data)) examples.\")","category":"page"},{"location":"manual/queries/#Full-Evidence-(EVI)","page":"Queries","title":"Full Evidence (EVI)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"EVI refers to computing the probability when full evidence is given, i.e. when x is fully observed, the output is p(x). We can use EVI method to compute logp(x):","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = EVI(pc, data);\nprobs[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Computing the EVI of a mixture of circuits works the same way. You may either pass weights for the weighted mixture probability, or pass a component index to individually evaluate each component.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"mix, mix_weights, _ = learn_strudel(data; num_mix = 10, init_maxiter = 10, em_maxiter = 100)\n# This computes the weighted probability\nprobs = EVI(mix, data, mix_weights);\n# Alternatively, we may want to compute the probability of a single component\nc_prob = EVI(mix, data; component_idx = 1);\nc_prob[1:3]","category":"page"},{"location":"manual/queries/#Partial-Evidence-(MAR)","page":"Queries","title":"Partial Evidence (MAR)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case we have some missing values. Let x^o denote the observed features, and x^m the missing features. We would like to compute p(x^o) which is defined as p(x^o) = sum_x^m p(x^o x^m). Of course, computing this directly by summing over all possible ways to fill the missing values is not tractable. ","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"The good news is that given a smooth and decomposable PC, the marginal can be computed exactly and in linear time to the size of the PC.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we randomly make some features go missing (you can also use make_missing_mcar from LogicCircuits library):","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using DataFrames\nfunction make_missing(d::DataFrame;keep_prob=0.8)\n    m = missings(Bool, num_examples(d), num_features(d))\n    flag = rand(num_examples(d), num_features(d)) .<= keep_prob\n    m[flag] .= Matrix(d)[flag]\n    DataFrame(m)\nend;\ndata_miss = make_missing(data[1:1000,:]);\nnothing #hide","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Now, we can use MAR to compute the marginal queries:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = MAR(pc, data_miss);\nprobs[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Note that MAR can also be used to compute probabilisties even if all data is observed, in fact it should give the same results as EVI. However, if we know all features are observed, we suggest using EVI as its faster in general.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs_mar = MAR(pc, data);\nprobs_evi = EVI(pc, data);\n\nprobs_mar ≈ probs_evi","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Just like EVI, MAR works the same way for mixtures.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"# Full weighted marginal probability\nprobs_mar = MAR(mix, data, mix_weights);\n# Individual component's marginal probability\nc_probs_mar = MAR(mix, data; component_idx = 1);\nc_probs_mar[1:3]","category":"page"},{"location":"manual/queries/#Conditionals-(CON)","page":"Queries","title":"Conditionals (CON)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given observed features x^o, we would like to compute p(Q mid x^o), where Q is a subset of features disjoint with x^o.  We can use Bayes rule to compute conditionals as two seperate MAR queries as follows:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"p(q mid x^o) = cfracp(q x^o)p(x^o)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Currently, this has to be done manually by the user. We plan to add a simple API for this case in the future.","category":"page"},{"location":"manual/queries/#Maximum-a-posteriori-(MAP,-MPE)","page":"Queries","title":"Maximum a posteriori (MAP, MPE)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given the observed features x^o the goal is to fill out the missing features in a way that p(x^m x^o) is maximized.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can use the MAP method to compute MAP, which outputs the states that maximize the probability and the log-likelihoods of each state.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"data_miss = make_missing(data,keep_prob=0.5);\nstates, probs = MAP(pc, data_miss);\nprobs[1:3]","category":"page"},{"location":"manual/queries/#Sampling","page":"Queries","title":"Sampling","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can also sample from the distrubtion p(x) defined by a Probabilistic Circuit. You can use sample to achieve this task.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"samples, lls = sample(pc, 100);\nlls[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Additionally, we can do conditional samples x sim p(x mid x^o), where x^o are the observed features (x^o subseteq x), and could be any arbitrary subset of features.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"#3 random evidences for the examples\nevidence = DataFrame(rand( (missing,true,false), (2, num_variables(pc))))\n\nsamples, lls = sample(pc, 3, evidence);\nlls","category":"page"},{"location":"manual/queries/#Expected-Prediction-(EXP)","page":"Queries","title":"Expected Prediction (EXP)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Expected Prediction (EXP) is the task of taking expectation of a discrimintative model w.r.t a generative model conditioned on evidemce (subset of features observed).","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"mathbbE_x^m sim p(x^m mid x^o)  f(x^o x^m) ","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In the case where f and p are circuit, and some structural constrains for the pair, we can do this expectation and higher moments tractably.  You can use Expectation and Moment to compute the expectations.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using DataFrames\n\npc = zoo_psdd(\"insurance.psdd\")\nrc = zoo_lc(\"insurance.circuit\", 1)\n\n# Using samples from circuit for the example; replace with real data\ndata, _ = sample(pc, 10);\ndata = make_missing(DataFrame(data));\n\nexps, exp_cache = Expectation(pc, rc, data)\n\nexps[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"second_moments, moment_cache = Moment(pc, rc, data, 2);\nexps[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"stds = sqrt.( second_moments - exps.^2 );\nstds[1:3]","category":"page"},{"location":"api/internals/utils/#api-internal-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/internals/utils/","page":"Utils","title":"Utils","text":"Modules = [ProbabilisticCircuits.Utils]","category":"page"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils","page":"Utils","title":"ProbabilisticCircuits.Utils","text":"Module with general utilities and missing standard library features  that could be useful in any Julia project\n\n\n\n\n\n","category":"module"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.DisCache","page":"Utils","title":"ProbabilisticCircuits.Utils.DisCache","text":"Cache pairwise / marginal distribution for all variables in one dataset\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.generate_all-Tuple{Array{T,1} where T}","page":"Utils","title":"ProbabilisticCircuits.Utils.generate_all","text":"Given some missing values generates all possible fillings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.generate_data_all-Tuple{Int64}","page":"Utils","title":"ProbabilisticCircuits.Utils.generate_data_all","text":"Generates all possible binary configurations of size N\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.mutual_information","page":"Utils","title":"ProbabilisticCircuits.Utils.mutual_information","text":"Calculate mutual information of given bit matrix bm, example weights w, and smoothing pseudocount α\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.one_hot_encode-Union{Tuple{T}, Tuple{Array{T,2},Array{T,1}}} where T","page":"Utils","title":"ProbabilisticCircuits.Utils.one_hot_encode","text":"One-hot encode data (2-D Array) based on categories (1-D Array) Each row of the return value is a concatenation of one-hot encoding of elements of the same row in data Assumption: both input arrays have elements of same type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.pairwise_marginals","page":"Utils","title":"ProbabilisticCircuits.Utils.pairwise_marginals","text":"Compute an array giving all pairwise marginals estimated on empirical (weighted) data\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#ProbabilisticCircuits.Utils.set_mutual_information-Tuple{Array{T,2} where T,AbstractArray{var\"#s54\",1} where var\"#s54\"<:(AbstractArray{T,1} where T)}","page":"Utils","title":"ProbabilisticCircuits.Utils.set_mutual_information","text":"Calculate set mutual information\n\n\n\n\n\n","category":"method"},{"location":"#ProbabilisticCircuits.jl","page":"Home","title":"ProbabilisticCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module provides a Julia implementation of Probabilistic Circuits (PCs),  tools to learn structure and parameters of PCs from data, and tools to do tractable exact inference with them. ","category":"page"},{"location":"#What-are-Probabilistic-Circuits?","page":"Home","title":"What are Probabilistic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits provides a unifying framework for several family of tractable probabilistic models. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given certain structural properties, PCs enable different range of tractable exact probabilistic queries such as computing marginals, conditionals, maximum a posteriori (MAP), and more advanced probabilistic queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In additon to parameters, the structure of PCs can also be learned from data. There are several approaches in learning PCs, while keeping the needed structural constrains intact. Currently, This module includes implementation for few of these approaches with plans to add more over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, parallelism (on both CPU and GPU) is leveraged to provide faster implementation of learning and inference.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For an overview of the motivation and theory behind PCs, you can start by watching the ECML-PKDD tutorial on Probabilistic Circuits. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: Representations, Inference, Learning and Theory (Video)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details and additional references, you can refer to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: A Unifying Framework for Tractable Probabilistic Models (PDF)","category":"page"}]
}
